---
layout:     post
title:      iOS大厂面试题
subtitle:   iOS大厂面试题总结
date:       2020-6-10
author:     eyuxin
header-img: img/post-bg-e4.jpg
catalog: true
tags:
    - iOS
    - 面试
---



## 这篇文章会记录下BAT，头条，拼多多的一些值得思考面试题



### 1.  拼多多的一道问题：设计一个方法，如果5秒钟之内没有获取到值返回nil, 否则返回这个值。

    ```objective-c
    - (id)timeoutFunction {
        dispatch_semaphore_t sema = dispatch_semaphore_create(0);
    	dispatch_async(dispatch_get_main_queue(), ^{
        	//do something
        	result = ***;
            dispatch_semaphore_signal(sema);
    	});
    	dispatch_semaphore_wait(sema, 5);
    	return result;
    }
    ```
    
    想起了另一个问题：GCD如何限制线程的最大并发数：
    
    ```objc
    dispatch_semaphore_t sema = dispatch_semaphore_create(m);
    for (NSInteger i = 0; i<n; i++） {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
            // doing
            dispatch_semaphore_signal(sema);
        });
    }
    ```

### 2.  拼多多的一道问题，performselector如何传递多参数

    >   注：performSelector:WithObject:AfterDelay的使用
    >
    >   1.  可以用p来延迟执行方法。比disptch_after轻便。
    >
    >   2.  如果在子线程调用performSelector:WithObject:AfterDelay无法执行，解决办法是用disptch_after或者在perform后调用[[NSRunLoop currentRunLoop] run];来开启runloop
    >   3.  防止按钮被多次点击， 可以在点击之后设置enabled=NO然后delay1s后恢复
    
    实际上这个问题考察了消息传递的理解
    
    1.  参数放字典/数组中传过去
    
    2.  自定义一个performselectorWithObjects的方法，然后通过NSInvocation去做消息转发。
    
        ```objc
        - (id)performSelector:(SEL)aSelector withObjects:(NSArray *)objects
            {
            NSMethodSignature *methodSignature = [[self class] instanceMethodSignatureForSelector:aSelector];
           if(methodSignature == nil)
             {
               //这里可以抛出异常
               return nil;
             }
             else
             {
               NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];
               [invocation setTarget:self];
               [invocation setSelector:aSelector];
               //签名中方法参数的个数，内部包含了self和_cmd，所以参数从第3个开始
               NSInteger  signatureParamCount = methodSignature.numberOfArguments - 2;
               NSInteger requireParamCount = objects.count;
               NSInteger resultParamCount = MIN(signatureParamCount, requireParamCount);
              for (NSInteger i = 0; i < resultParamCount; i++) {
                id  obj = objects[i];
                [invocation setArgument:&obj atIndex:i+2];
              }
             [invocation invoke]；
            //返回值处理
            id callBackObject = nil;
            if(methodSignature.methodReturnLength)
            {
                [invocation getReturnValue:&callBackObject];
            }
            return callBackObject;
           }
         }
        ```
    
    引申问题： 默认参数是id类型的，如果需要传递基础数据类型甚至是struct要怎么做呢？
    
    方法1：修改参数类型为指针
    
    ```objc
    - (NSString *)doubleToString:(double *)number {
    	return [NSString stringWithFormat:@"%f", *number];
    }
    double number = 123.456;
    [test performSelector:@selector(doubleToString:) withObject:(id)(&number)];
    ```
    
    方法2： 结构体用NSValue转换
    
    ```objective-c
    //创建一个结构体
    SteveDate date = {2010,10,20};
    //把结构体转换为NSValue类型
    NSValue *dateValue = [NSValue valueWithBytes:&date objCType:@encode(SteveDate)]; 
    ```
    
    然后再从NSValue中取出结构体赋值给void*
    
    ```objc
    NSValue *anObj = obj;
    SteveDate struct;
    [anObj getValue:&struct];
    ```


​    

    方法3：基础数据类型用NSNumber转换 
    
    ```objective-c
    - (void)setInv:(NSInvocation *)inv andArgs:(NSArray *)args argsCount:(NSUInteger)count{
        for (int i = 0; i<count; i++) {
            NSObject*obj = args[i];
            //处理参数是NULL类型的情况
            if ([obj isKindOfClass:[NSNull class]]) {
                obj = nil;
            }
            //对整形数值等的处理
            if([obj isKindOfClass:[NSNumber class]])      //对数值数据的处理
            {
                void *p;
                NSNumber *num = (NSNumber *)obj;
                if(strcmp([num objCType], @encode(float)) == 0)
                {
                    float v = [num floatValue];
                    p = &v;
                }
                else if(strcmp([num objCType], @encode(double)) == 0)
                {
                    double v = [num doubleValue];
                    p = &v;
                }
                else
                {
                    long v = [num longValue];
                    p = &v;
                }
                [inv setArgument:p atIndex:i+2];
            }
    
            [inv setArgument:&obj atIndex:i+2];
        }
    }
    ```



### 3.  拼多多面试题：如果处理苹果内购掉单问题

之前做个内购相关的工作，我总结下来主要分为几种情况：

1.  与苹果服务器通信中途中断

    通过addTransactionObserver可以在下次启动App的时候监听到，之前中断的支付可以继续进行

2.  App端与服务器端通信失败或者自己服务器端与 AppStore 服务器之间的通信失败。

    App 端需要做接口重试，设置一个重试的逻辑。新建一个数据表（字段有：transactionIdentifier、productIdentifier、uid、transactionDate(支付时间)、rechargeDate(充值到账时间)、state(「已支付」和「已充值」)），存每一笔交易。






